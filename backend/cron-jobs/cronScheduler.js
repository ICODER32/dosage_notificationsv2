import cron from "node-cron";
import moment from "moment-timezone";
import User from "../models/user.model.js";
import twilio from "twilio";
import dotenv from "dotenv";
import { Router } from "express";
import mongoose from "mongoose";
dotenv.config();
import {
  calculateReminderTimes,
  generateMedicationSchedule,
} from "../utils/scheduler.js";

const client = twilio(
  process.env.TWILIO_ACCOUNT_SID,
  process.env.TWILIO_AUTH_TOKEN
);

// Router for call handling
const callRouter = Router();

// Helper function to make interactive phone calls
export async function makeInteractiveCall(phoneNumber, notificationId) {
  try {
    const call = await client.calls.create({
      url: `http://18.218.16.247/api/calls/handle?notificationId=${notificationId}`,
      to: `+${phoneNumber}`,
      from: process.env.TWILIO_PHONE_NUMBER,
    });
    return call; // contains call.sid if accepted
  } catch (error) {
    console.error(`‚ùå Error making call to ${phoneNumber}:`, error.message);
    throw new Error("CALL_NOT_PLACED"); // only trigger SMS fallback if not accepted
  }
}

// Helper function to send SMS
async function sendSMS(phoneNumber, message) {
  try {
    const sms = await client.messages.create({
      body: message,
      from: process.env.TWILIO_PHONE_NUMBER,
      to: `+${phoneNumber}`,
    });
    console.log(message);
    console.log(`üí¨ SMS sent to ${phoneNumber}: ${sms.sid}`);
    return sms;
  } catch (error) {
    console.error(`‚ùå Error sending SMS to ${phoneNumber}:`, error);
    throw error;
  }
}

/**
 * Cron Job ‚Äî Send reminders
 * Runs every minute and sends per-medication calls/SMS
 */
export function startReminderCron() {
  cron.schedule("* * * * *", async () => {
    const now = moment.utc();

    try {
      const users = await User.find({ notificationsEnabled: true });

      for (const user of users) {
        const userTimezone = user.timezone || "UTC";

        // Filter due reminders
        const dueReminders = user.medicationSchedule.filter(
          (r) =>
            r.status === "pending" &&
            !r.reminderSent &&
            moment.utc(r.scheduledTime).isSame(now, "minute")
        );

        if (dueReminders.length === 0) continue;

        // === group reminders by scheduled time ===
        const groupedReminders = dueReminders.reduce((acc, reminder) => {
          const timeKey = moment.utc(reminder.scheduledTime).format(); // ISO minute key
          if (!acc[timeKey]) acc[timeKey] = [];
          acc[timeKey].push(reminder);
          return acc;
        }, {});

        // Process each group (time slot)
        for (const [timeKey, remindersAtSameTime] of Object.entries(
          groupedReminders
        )) {
          const scheduleIds = remindersAtSameTime.map((r) => r._id);
          const meds = remindersAtSameTime.map((r) => r.prescriptionName);

          const timeStr = moment
            .utc(remindersAtSameTime[0].scheduledTime)
            .tz(userTimezone)
            .format("h:mm A");

          // Build single message
          const message = `It's time to take your medications:\n${meds
            .map((m) => `‚Ä¢ ${m} at ${timeStr}`)
            .join(
              "\n"
            )}\n\nReply:\nD - if taken\nS - if skipped\n\nThank you for using CareTrackRx.`;

          // Push single notification
          const notification = {
            sentAt: now.toDate(),
            message: `Reminder for ${meds.join(", ")}`,
            status: "pending",
            medications: meds,
            scheduleIds,
            resends: 0,
            notificationType: user.notificationType || "sms",
          };

          // === Send notification IMPERATIVELY first ===
          // If this fails, we won't mark as sent in DB, so it retries.
          let callSid = null;
          let smsSid = null;
          let sentSuccessfully = false;

          if (user.notificationType === "call") {
            // We need an ID for the callbacks/interactions, even if not yet saved. 
            // Ideally we generate specific ID or let Mongo do it. 
            // For simplicity, we can let the notification ID be generated by push, 
            // but we are doing atomic update. 
            // Let's generate a temporary ID or just rely on atomic update returning it? 
            // No, standard is to just send. If we need ID for call URL, 
            // we might need to generate ObjectId client-side or use a two-step if strictly needed.
            // However, makeInteractiveCall uses notificationId in URL.
            // So we must generate it.

            // In Mongoose subdocs have _ids by default. 
            // But here we are constructing a plain object to push.
            // Let's manually assign an _id so we can use it in the call URL.
            notification._id = new mongoose.Types.ObjectId();

            try {
              const call = await makeInteractiveCall(
                user.phoneNumber,
                notification._id
              );
              if (call && call.sid) {
                callSid = call.sid;
                sentSuccessfully = true;
                console.log(`üìû Call placed: ${call.sid}`);
              }
            } catch (error) {
              if (error.message === "CALL_NOT_PLACED") {
                // Fallback
                console.log("‚ö†Ô∏è Fallback to SMS");
                try {
                  const sms = await sendSMS(user.phoneNumber, message);
                  smsSid = sms.sid;
                  sentSuccessfully = true;
                } catch (e) { console.error("Fallback failed", e); }
              }
            }
          } else {
            try {
              const sms = await sendSMS(user.phoneNumber, message);
              smsSid = sms.sid;
              sentSuccessfully = true;
            } catch (e) { console.error("SMS failed", e); }
          }

          // === Mark all reminders in this slot as sent ATOMICALLY ===
          if (sentSuccessfully) {
            await User.updateOne(
              { _id: user._id },
              {
                $push: { notificationHistory: notification },
                $set: {
                  "medicationSchedule.$[elem].reminderSent": true
                }
              },
              {
                arrayFilters: [{ "elem._id": { $in: scheduleIds } }]
              }
            );
          }
        }
      }
    } catch (err) {
      console.error("‚ùå Cron job error:", err.message);
    }
  });
}

/**
 * Notify caregivers when meds are skipped/missed
 */
export async function notifyCaregivers(user, reminders, operation) {
  if (!user.caregivers || user.caregivers.length === 0) return;

  const prescriptionsMap = {};
  reminders.forEach((reminder) => {
    const prescription = user.prescriptions.find(
      (p) => p.name === reminder.prescriptionName
    );
    if (prescription) {
      if (!prescriptionsMap[prescription.username]) {
        prescriptionsMap[prescription.username] = [];
      }
      prescriptionsMap[prescription.username].push({
        name: prescription.name,
        forWho: prescription.forWho,
      });
    }
  });

  for (const caregiver of user.caregivers) {
    if (!caregiver.notificationsEnabled) continue;

    let medicationsToNotify = [];

    caregiver.forPersons.forEach((person) => {
      if (prescriptionsMap[person]) {
        medicationsToNotify.push(...prescriptionsMap[person]);
      }
    });

    if (medicationsToNotify.length === 0) continue;

    const skippedFor = Object.keys(prescriptionsMap).join(", ");

    const message =
      `‚ö†Ô∏è ${skippedFor} has ${operation}:\n` +
      medicationsToNotify.map((m) => `‚Ä¢ ${m.name}`).join("\n");

    try {
      await sendSMS(caregiver.phoneNumber, message);
      console.log(`   üë©‚Äç‚öïÔ∏è Caregiver notified: ${caregiver.phoneNumber}`);
    } catch (error) {
      console.error(
        `   ‚ùå Failed caregiver SMS ${caregiver.phoneNumber}:`,
        error
      );
    }
  }
}

/**
 * Cron Job ‚Äî Follow-up reminders
 */
export function startReminderFollowupCron() {
  cron.schedule("*/1 * * * *", async () => {
    const now = moment.utc();
    console.log(
      `üîÅ Follow-up check at ${now.format("YYYY-MM-DD HH:mm:ss")} UTC`
    );

    try {
      const users = await User.find({
        status: "active",
        notificationsEnabled: true,
        "notificationHistory.status": "pending",
      });

      for (const user of users) {
        const pendingNotifications = user.notificationHistory.filter(
          (n) => n.status === "pending"
        );

        for (const notification of pendingNotifications) {
          const sentAt = moment(notification.sentAt);
          const minutesPassed = now.diff(sentAt, "minutes");

          if (notification.resends === 0 && minutesPassed >= 20) {
            await sendFollowupReminder(user, notification, 1);
          } else if (notification.resends === 1 && minutesPassed >= 30) {
            await sendFollowupReminder(user, notification, 2);
          } else if (notification.resends === 2 && minutesPassed >= 40) {
            notification.status = "skipped";
            console.log(`üö´ Reminder skipped for ${user.phoneNumber}`);
            const skippedReminders = notification.medications.map((name) => ({
              prescriptionName: name,
            }));
            await notifyCaregivers(user, skippedReminders, "missed");
          }
        }

        await user.save();
      }
    } catch (err) {
      console.error("üö® Error in follow-up cron:", err);
    }
  });
}

async function sendFollowupReminder(user, notification, resendCount) {
  try {
    const medList = notification.medications.join(", ");
    const message = `Reminder \n\n It's time to take your medications:  \n ${medList}\n\n Please Reply:\nD ‚Äì if you have taken them \nS ‚Äì if you need to skip the dose. \n\n Thank you for using CareTrackRx.`;

    if (user.notificationType === "call" && resendCount === 0) {
      try {
        await makeInteractiveCall(user.phoneNumber, notification._id);
      } catch (error) {
        await sendSMS(user.phoneNumber, message);
      }
    } else {
      await sendSMS(user.phoneNumber, message);
    }

    console.log(`üì§ Follow-up sent to ${user.phoneNumber}`);
    notification.resends = resendCount;
  } catch (error) {
    console.error(`‚ùå Follow-up failed for ${user.phoneNumber}:`, error);
    notification.status = "failed";
    notification.error = error.message;
  }
}

/**
 * (Optional) Nightly refresh of medication schedules
 */
function scheduleNightlyRefresh() {
  cron.schedule("0 3 * * *", async () => {
    const activeUsers = await User.find({ status: "active" });

    for (const user of activeUsers) {
      const enabledMeds = user.prescriptions.filter((p) => p.remindersEnabled);

      const allReminders = enabledMeds.flatMap((p) =>
        calculateReminderTimes(
          user.wakeTime,
          user.sleepTime,
          p.instructions,
          p.timesToTake,
          p.name,
          p.tracking.pillCount,
          p.dosage,
          p._id
        )
      );

      const completedItems = user.medicationSchedule.filter(
        (item) => item.status !== "pending"
      );

      const newSchedule = generateMedicationSchedule(
        allReminders,
        user.timezone
      );

      user.medicationSchedule = [...completedItems, ...newSchedule];
      await user.save();
    }
  });
}

/**
 * Cron Job ‚Äî Low-pill reminder (less than 2 days left)
 * Runs daily at 9 AM UTC
 */
export function startLowPillCheckCron() {
  // Runs every day at 9 AM Pakistan time
  cron.schedule(
    "0 14 * * *",
    async () => {
      const now = moment.utc();
      console.log(
        `üßæ Low-pill check running at ${now.format("YYYY-MM-DD HH:mm:ss z")}`
      );

      try {
        const users = await User.find({
          status: "active",
          notificationsEnabled: true,
        });

        for (const user of users) {
          if (!user.prescriptions || user.prescriptions.length === 0) continue;

          const lowPillPrescriptions = [];

          for (const prescription of user.prescriptions) {
            const totalPills = prescription.initialCount || 0;
            const timesToTake = prescription.timesToTake || 1;
            const dosage = prescription.dosage || 1;

            // Each day consumes dosage * timesToTake pills
            const pillsPerDay = dosage * timesToTake;

            // If you‚Äôre tracking remaining pills dynamically, replace this with prescription.tracking.remainingCount
            const remainingPills =
              prescription.tracking?.pillCount ?? totalPills;

            if (!remainingPills || remainingPills <= 0) continue;

            const daysLeft = remainingPills / pillsPerDay;

            if (daysLeft <= 1 && remainingPills > 0) {
              lowPillPrescriptions.push({
                name: prescription.name,
                daysLeft: daysLeft.toFixed(1),
              });
            }
          }

          if (lowPillPrescriptions.length > 0) {
            const message = `‚ö†Ô∏è You have 1 day or less of pills left for:\n${lowPillPrescriptions
              .map((m) => `‚Ä¢ ${m.name} (${m.daysLeft} days left)`)
              .join(
                "\n"
              )}\n\nPlease arrange a refill soon.\nThank you for using CareTrackRx!`;

            try {
              await sendSMS(user.phoneNumber, message);
              console.log(`üíä Low-pill reminder sent to ${user.phoneNumber}`);
            } catch (error) {
              console.error(
                `‚ùå Failed low-pill SMS for ${user.phoneNumber}:`,
                error.message
              );
            }
          }
        }
      } catch (err) {
        console.error("üö® Error in low-pill check cron:", err.message);
      }
    }
  );
}

/**
 * Cron Job ‚Äî Prescription over (pill count = 0)
 * Runs daily at 10 AM UTC
 */
export function startPrescriptionOverCron() {
  cron.schedule("0 10 * * *", async () => {
    const now = moment.utc();
    console.log(
      `üóëÔ∏è Prescription-over check at ${now.format("YYYY-MM-DD HH:mm:ss")} UTC`
    );

    try {
      const users = await User.find({ status: "active" });

      for (const user of users) {
        if (!user.prescriptions || user.prescriptions.length === 0) continue;

        const zeroPillPrescriptions = user.prescriptions.filter(
          (p) => p.tracking && p.tracking.pillCount <= 0 && !p.finishedNotified
        );

        if (zeroPillPrescriptions.length === 0) continue;

        // Send message before deleting
        const message = `‚úÖ Your prescription period is complete for:\n${zeroPillPrescriptions
          .map((p) => `‚Ä¢ ${p.name}`)
          .join(
            "\n"
          )}\n\nPlease contact your doctor if you need a refill.\nStay healthy!`;

        try {
          await sendSMS(user.phoneNumber, message);
          console.log(`üì® Prescription-over SMS sent to ${user.phoneNumber}`);

          // Mark as notified
          zeroPillPrescriptions.forEach(p => p.finishedNotified = true);
          await user.save();

        } catch (error) {
          console.error(
            `‚ùå Failed to send end SMS to ${user.phoneNumber}:`,
            error
          );
        }

        // User deletion removed. Only notifying.
        // await User.deleteOne({ _id: user._id });
        // console.log(`üóëÔ∏è User ${user.phoneNumber} deleted due to zero pills.`);
      }
    } catch (err) {
      console.error("üö® Error in prescription-over cron:", err);
    }
  });
}

// Uncomment if you want to auto-refresh
// scheduleNightlyRefresh();

export default callRouter;
